Kafka消费者通过向负责它要消费消息的broker发出拉取请求来工作。消费者在每个请求中指定消息在日志中的偏移量，接收到从改位置开始的块数据。因此消费者拥有该位置的重要控制权，并且如果需要的化可以回退到该位置再次消费数据。
- Push vs. pull
Kafka采用一种传统的设计，数据从生产者推送到broker，消费者从broker拉取数据。一些以日志为中心的系统，采用一种不同的基于推送的方式由下游推送消息。这两种方式都既有优点又有缺点。然而，基于推送的系统很难处理多种消费者，因为broker控制数据传输的速率。对于消费者来说，目标通常是可以以尽可能大的速率消费数据，不幸的是，对于推送系统来说这意味着消费者的消费速率低于生产速率时消费者往往不堪重负（本质上是拒绝服务攻击）。一个基于拉取的系统拥有更好的性质：消费者的速率落后于生产者时，可以在适当的时间追赶上来。通过使用某种backoff协议，这个问题可以减轻，消费者可以通过这种协议表明它已经不堪重负了，但是想要充分利用（但不是过度利用）消费者的传输速率，就比看起来的要棘手的多。先前以这种方式构建系统的尝试使我们选择一种更传统的拉取模型。
基于拉取的系统的另外一个优点是它有助于对发送给消费者的数据做积极的批处理。基于推送的系统必须选择是立即发送一个请求还是堆积更多数据在晚些时候发送，而无需知道下游消费者何时可以立即处理信息。